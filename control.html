<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Creator Clash â€” Control</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
  <style>
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial; color: #cfeaff; background: #08121b; }
    .wrap { max-width: 720px; margin: 24px auto; padding: 16px; border:1px solid rgba(255,255,255,0.15); border-radius: 12px; background: rgba(255,255,255,0.04); }
    .row { display:flex; gap:8px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
    .btn { background: rgba(255,255,255,0.08); color:#e6f4ff; border:1px solid rgba(255,255,255,0.2); border-radius: 8px; padding:8px 12px; cursor:pointer; position:relative; }
    .btn:disabled { opacity: .55; cursor: not-allowed; }
    input, select { background: rgba(255,255,255,0.08); color:#e6f4ff; border:1px solid rgba(255,255,255,0.2); border-radius:6px; padding:6px 8px; }
    h1 { margin: 0 0 10px; font-size: 24px; }
    small { opacity: .8 }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Remote Control</h1>
    <div class="row">
      <label>Room <input id="room" type="text" placeholder="ABC123" style="width:120px" /></label>
      <button id="connect" class="btn">Connect</button>
      <button id="disconnect" class="btn" disabled>Disconnect</button>
      <small id="status">Not connected</small>
    </div>
    <div id="remoteFeedback" style="margin:-4px 0 10px; font-size:12px; min-height:16px; color:#7dd3fc"></div>

    <div class="row">
      <button class="btn" id="addCrystals100" data-ev="addCrystals" data-amt="100">+100ðŸ’°</button>
      <button class="btn" id="addCrystals1000" data-ev="addCrystals" data-amt="1000">+1000ðŸ’°</button>
      <button class="btn" id="fullHeal" data-ev="fullHeal">Full Heal</button>
      <button class="btn" id="forceVictory" data-ev="forceVictory">Force Victory</button>
    </div>

    <div class="row">
      <select id="rarity">
        <option value="common">Common</option>
        <option value="rare">Rare</option>
        <option value="epic">Epic</option>
        <option value="legend">Legend</option>
      </select>
      <button class="btn" id="addByRarity" data-ev="addByRarity">Add Unit (Rarity)</button>
      <input id="name" type="text" placeholder="Name" style="width:160px" />
      <button class="btn" id="addByName" data-ev="addByName">Add Unit (Name)</button>
    </div>

    <div class="row">
      <label>Stage <input id="stage" type="number" min="1" step="1" style="width:90px" /></label>
      <button class="btn" id="setStage" data-ev="setStage">Set Stage</button>
      <label>Enemy HP <input id="ehp" type="number" min="0" step="1" style="width:110px" /></label>
      <button class="btn" id="setEnemyHp" data-ev="setEnemyHp">Set HP</button>
    </div>

    <div class="row">
      <button class="btn" id="spawnFx" data-ev="spawnFx">Spawn FX âœ¨</button>
      <input id="msgText" type="text" maxlength="60" placeholder="Show message" style="width:220px" />
      <button class="btn" id="showMessage" data-ev="showMessage">Show Message ðŸ’¬</button>
    </div>

    <small>Tip: Open from the game's Settings â†’ Remote Control â†’ Open Control to auto-fill room.</small>
  </div>

  <script type="module">
    let client = null; let channel = null; let roomCode = '';
    const statusEl = document.getElementById('status');
    const setStatus = (t) => statusEl.textContent = t;

    function getRoomFromHash() {
      const m = location.hash.match(/room=([A-Za-z0-9]+)/);
      return m ? m[1] : '';
    }

    async function connect(room) {
      if (!window.Ably) return setStatus('Ably SDK missing');
      if (!room) { setStatus('Enter room'); return; }
      client = new Ably.Realtime.Promise({ authUrl: '/api/ably-token' });
      await client.connection.once('connected');
      channel = client.channels.get(`creatorclash-${room}`);
      roomCode = room;
      setStatus(`Connected â†’ ${room}`);
      document.getElementById('connect').disabled = true;
      document.getElementById('disconnect').disabled = false;
      channel.subscribe(msg => {
        try {
          const data = typeof msg.data === 'string' ? JSON.parse(msg.data) : msg.data;
          if (data?.type === 'remoteAck') {
            const { action, status, left } = data.payload || data;
            let text=''; let kind='info';
            switch(status){
              case 'ok': text = `âœ… ${action} executed`; break;
              case 'locked': text = `ðŸ”’ Action blocked (locked)`; kind='warn'; break;
              case 'denied': text = `â›” Permission denied for ${action}`; kind='error'; break;
              case 'cooldown': text = `â³ ${action} cooldown ${(left/1000).toFixed(1)}s`; kind='warn'; break;
              case 'unknown': text = `â“ Unknown action ${action}`; kind='warn'; break;
              case 'error': text = `âš ï¸ Error executing ${action}`; kind='error'; break;
              default: break;
            }
            if (text) setFeedback(text, kind);
          } else if (data?.type === 'remoteStatus') {
            const { lock, level } = data.payload || data;
            setFeedback(lock ? `ðŸ”’ Locked â€¢ Perm L${level}` : `ðŸŸ¢ Ready â€¢ Perm L${level}`,'info');
          }
        } catch {}
      });
    }
    async function disconnect() {
      try { if (channel) await channel.detach(); if (client) await client.close(); }
      finally { channel = null; client = null; setStatus('Not connected'); document.getElementById('connect').disabled = false; document.getElementById('disconnect').disabled = true; }
    }
    async function publish(type, payload={}) {
      if (!channel) return setStatus('Not connected');
      await channel.publish(type, { type, payload, t: Date.now() });
    }
    function setFeedback(text, kind='info') {
      const el = document.getElementById('remoteFeedback');
      if (!el) return; el.textContent = text;
      el.style.color = kind==='error' ? '#f87171' : (kind==='warn' ? '#fbbf24' : '#7dd3fc');
    }

    const roomInput = document.getElementById('room');
    roomInput.value = getRoomFromHash();
    document.getElementById('connect').onclick = () => connect(roomInput.value.trim());
    document.getElementById('disconnect').onclick = () => disconnect();

    const cooldowns = {
      addCrystals: 3000,
      fullHeal: 10000,
      forceVictory: 15000,
      addByRarity: 5000,
      addByName: 8000,
      setStage: 12000,
      setEnemyHp: 5000,
      spawnFx: 2000,
      showMessage: 5000,
    };
    const lastUsed = {};

    function useAction(type, payload) {
      const now = Date.now();
      const next = lastUsed[type] || 0;
      if (now < next) return;
      publish(type, payload);
      lastUsed[type] = now + (cooldowns[type] || 0);
      document.querySelectorAll(`[data-ev="${type}"]`).forEach(btn => {
        btn.disabled = true;
        const cd = cooldowns[type] || 0;
        btn.dataset.cdEnd = String(now + cd);
        setTimeout(() => { btn.disabled = false; if (btn.dataset.baseLabel) btn.textContent = btn.dataset.baseLabel; btn.removeAttribute('data-cd-end'); }, cd);
      });
    }

    let cdTickerStarted = false;
    function startCdTicker(){
      if (cdTickerStarted) return; cdTickerStarted = true;
      document.querySelectorAll('[data-ev]').forEach(btn => { btn.dataset.baseLabel = btn.textContent; });
      function tick(){
        const now = Date.now();
        document.querySelectorAll('[data-cd-end]').forEach(btn => {
          const end = parseInt(btn.dataset.cdEnd,10)||0;
          if (end > now) {
            const left = (end - now)/1000;
            btn.textContent = `${btn.dataset.baseLabel} (${left.toFixed(1)}s)`;
          }
        });
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }
    startCdTicker();

    document.querySelectorAll('[data-ev]').forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.ev;
        switch(type) {
          case 'addCrystals': return useAction(type, { amount: parseInt(btn.dataset.amt, 10) });
          case 'fullHeal': return useAction(type, {});
          case 'forceVictory': return useAction(type, {});
          case 'addByRarity': return useAction(type, { rarity: document.getElementById('rarity').value });
          case 'addByName': return useAction(type, { name: (document.getElementById('name').value || '').trim() });
          case 'setStage': return useAction(type, { stage: parseInt(document.getElementById('stage').value, 10) });
          case 'setEnemyHp': return useAction(type, { hp: parseInt(document.getElementById('ehp').value, 10) });
          case 'spawnFx': return useAction(type, {});
          case 'showMessage': return useAction(type, { text: (document.getElementById('msgText').value || '').trim() });
          default: break;
        }
      });
    });
  </script>
</body>
</html>
